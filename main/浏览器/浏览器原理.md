### Chrome浏览器原理

#### 浏览器多进程架构
 
##### 为什么不继续采用单进程

* 不稳定；
  * 早期浏览器需要借助于插件来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的JavaScript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃

* 不流畅；
  * 所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。一个死循环的脚本，当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢
  
* 不安全；
  * 插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。

##### 多进程架构

* 渲染进程
  * 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
* GPU进程
  * 其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。
* 插件进程
  * 比如说flash（毒瘤）
* 网络进程
  * 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的。
* 浏览器主进程
  * 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

##### 所以打开一个浏览器，为什么有四个进程？

因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。

#### 如何保证页面文件能被完整送达浏览器

##### 一个数据包的旅程

* 互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。比如你现在听的音频数据，是拆分成一个个小的数据包来传输的，并不是一个大的文件一次传输过来的

1. IP：把数据包送达到目的主机
 - 数据包需要在网络上传输，就需要符合ip协议。网络请求就是一台计算机向另一台计算机请求信息。
 - 如果想把数据包从主机A发送到主机B，在传输前就需要在数据包上附带上主机B的ip地址，这样进行寻址，送到指定的地方。同时，还需要在数据包上附带上A的地址信息，这样在主机B上收到后，才能回复是否已经收到数据包了。这些附加的信息会被装进一个叫IP头的数据结构里。IP头是IP数据包开头的信息，包含IP版本、源IP地址、目标IP地址、生存时间等信息
 - 数据包从A到B的旅程
   - 应用层把需要传输的数据包交付给网络层
   - 网络层再把IP头附加到数据包上，再交付给数据链路层
   - 数据链路层经过硬件通道把数据传输给主机B
   - 数据包被主机B交付给网络层把数据包和IP头拆开，把数据包交付给应用层
   - 最终该数据包就到达了主机B的应用层

2. UDP：把数据包送达到对应的应用程序
   - ip是非常属于网络层的协议，只负责把数据发送到别人的设备上，并不知道数据应该给哪个应用程序。因此需要开发基于ip之上能够与应用层打交道的协议，最常见的就是‘用户数据包协议’，UDP
   - UDP比较重要的信息就是端口号了，每个想访问网络的程序都会绑定一个端口号。在发出数据包的时候。通过端口号，UDP能够把对应的信息交付给对应的程序。
   - IP通过地址把数据给正确的电脑，UDP通过端口号把数据给正确的程序。
   - 和IP一样，端口号会把端口放到UDP头上，而UDP头再和数据包组成新的数据包。同样UDP头中会包含目标端口号和源端口号的信息。
   - UDP是属于传输层的协议
   - 数据包从A到B的旅程
     - 应用层里的程序把需要传输的数据包交付给传输层
     - 传输层给这个数据包添加上UDP头，把数据包再交付给网络层
     - 网络层再把数据包添加上IP头，把数据包交付给数据链路层
     - 数据链路层通过硬件把数据传输给主机B
     - 数据包经由网络层把数据包中ip头和数据包拆开，交付给传输层
     - 再由传输层层把数据包中的UDP头和数据包拆开，根据其中的目标端口信息，把数据包给指定的程序。
   - 在使用UDP发送数据时，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是对于错误的数据包，UDP并不提供重发机制，只是丢弃当前的包，而且UDP在发送之后也无法知道是否能达到目的地。
   - 虽然UDP不能保证数据可靠性，但是传输速度却非常快，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等

3. TCP：把数据完整地送达应用程序
   - 对于浏览器请求，或者是邮件这类请求要求请求可靠性的应用来说，使用UDP传输会存在两个问题：
     - 数据包在传输的过程中容易丢失
     - 大文件会被拆分成很多小数据包进行传输，这些数据包会经过不同的路由，不同的时间到达接收端。而UDP协议不知道如何组装这些数据包，从而还原成源文件
   - 基于这个原因，引入了‘传输控制协议’TCP，它是面向连接的，可靠的，基于字符流的传输层控制协议。相比较与UDP，它有以下两个特点
     - 对于丢失的数据包，TCP提供了重发机制
     - 对于组装数据包，TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。
   - TCP头提供了目标端口和原端口号信息，还提供了用于排序的序列号，以便接收端通过序号重新排序组装数据包
   - TCP传输流程和UDP流程差不多，不过通过TCP头信息保证传输的一大块数据的完整性和连续性
   - TCP连接过程
     - 建立连接阶段；这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个TCP连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
     - 传输数据阶段；在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照TCP头中的序号为其排序，从而保证组成完整的数据。
     - 断开连接阶段；数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接
   - TCP为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。